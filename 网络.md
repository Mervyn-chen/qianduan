## 1、TCP、UDP的区别

（1）TCP是面向连接的，UDP是无连接的，即发送数据前不需要建立连接

（2）TCP提供可靠的服务，通过TCP连接传输的数据无差错、不丢失、不重复，且按序到达，适合大数据量的交换；UDP尽最大努力交付，但不保证可靠。

（3）TCP是面向字节流；UDP面向报文，并且网络出现拥塞，不会使发送速率降低（会出现丢包，比如IP电话或者视频会议）；

（4）TCP只能端对端；UDP支持1对1，1对多，多对多，多对一。

（5）TCP的首部较大，为20字节；UDP只有8字节。

## 2、TCP三次连接、四次挥手

在创建连接时，

1.客户端首先要SYN=1,表示要创建连接，

2.服务端接收到后，要告诉客户端：我接受到了！所以加个ACK=1，就变成了ACK=1,SYN=1

3.理论上这时就创建连接成功了，但是要防止一个意外（见疑问三），所以客户端要再发一个消息给服务端确认一下，这时只需要ACK=1就行了。

三次握手完成！

在四次分手时，

1.首先客户端请求关闭客户端到服务端方向的连接，这时客户端就要发送一个FIN=1，表示要关闭一个方向的连接（见上面四次分手的图）

2.服务端接收到后是需要确认一下的，所以返回了一个ACK=1

3.这时只关闭了一个方向，另一个方向也需要关闭，所以服务端也向客户端发了一个FIN=1 ACK=1

4.客户端接收到后发送ACK=1，表示接受成功

四次分手完成！

## 3、TCP的三次握手，四次挥手。为什么TCP是三次握手而不是两次握手？为什么TCP是四次挥手？

**为什么需要三次握手**

如果发送两次就可以建立连接话，那么只要客户端发送一个连接请求，服务端接收到并发送了确认，就会建立一个连接。

**可能出现的问题：**如果一个连接请求在网络中跑的慢，超时了，这时客户端会从发请求，但是这个跑的慢的请求最后还是跑到了，然后服务端就接收了两个连接请求，然后全部回应就会创建两个连接，浪费资源！

如果加了第三次客户端确认，客户端在接受到一个服务端连接确认请求后，后面再接收到的连接确认请求就可以抛弃不管了。

**为什么需要四次分手**

TCP是双向的，所以需要在两个方向分别关闭，每个方向的关闭又需要请求和确认，所以一共就4次。

## 4、什么是XSS，如何防止XSS？什么是CSRF，如何防止CSRF？

**XSS（跨站脚本攻击）** 

XSS 攻击是指攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。会将一些隐私数据像 cookie、session 发送给攻击者，将受害者重定向到一个由攻击者控制的网站，在受害者的机器上进行一些恶意操作。

**XSS攻击防范** 

**HttpOnly 防止劫取 Cookie**：浏览器将禁止页面的Javascript 访问带有 HttpOnly 属性的Cookie。攻击者可以通过注入恶意脚本获取用户的 Cookie 信息。通常 Cookie 中都包含了用户的登录凭证信息，攻击者在获取到 Cookie 之后，则可以发起 Cookie 劫持攻击。所以，严格来说，HttpOnly 并非阻止 XSS 攻击，而是能阻止 XSS 攻击后的 Cookie 劫持攻击。

**输入、输出检查**在 XSS 防御中，输入检查一般是检查用户输入的数据中是否包含 <，> 等特殊字符，如果存在，则对特殊字符进行过滤或编码，这种方式也称为 XSS Filter。而在一些前端框架中，都会有一份 decodingMap， 用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 <，>，script，防止 XSS 攻击。

**CSRF/XSRF（跨站请求伪造）** 

CSRF，即 Cross Site Request Forgery，中译是跨站请求伪造，是一种劫持受信任用户向服务器发送非预期请求的攻击方式。通常情况下，CSRF 攻击是攻击者借助受害者的 Cookie 骗取服务器的信任，可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击服务器，从而在并未授权的情况下执行在权限保护之下的操作。

**CSRF攻击防范** 

**验证码**：验证码会强制用户必须与应用进行交互，才能完成最终请求。因为通常情况下，验证码能够很好地遏制 CSRF 攻击。但验证码并不是万能的，因为出于用户考虑，不能给网站所有的操作都加上验证码。因此，验证码只能作为防御 CSRF 的一种辅助手段，而不能作为最主要的解决方案。

**Referer Check**：根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。通过 Referer Check，可以检查请求是否来自合法的"源"。

**添加token验证**：要抵御 CSRF，关键在于在请求中放入攻击者所不能伪造的信息，并且该信息不存在于 Cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。

## 4、强缓存和协商缓存

缓存分为强缓存和协商缓存。**强缓存不过服务器，协商缓存需要过服务器，协商缓存返回的状态码是304。**两类缓存机制可以同时存在，强缓存的优先级高于协商缓存。当执行强缓存时，如若缓存命中，则直接使用缓存数据库中的数据，不再进行缓存协商。

**强缓存** 

**Expires(HTTP1.0)**：Exprires的值为服务端返回的数据到期时间。当再次请求时的请求时间小于返回的此时间，则直接使用缓存数据。但由于服务端时间和客户端时间可能有误差，这也将导致缓存命中的误差。另一方面，Expires是HTTP1.0的产物，故现在大多数使用Cache-Control替代。

缺点：使用的是绝对时间，如果服务端和客户端的时间产生偏差，那么会导致命中缓存产生偏差。

**Pragma(HTTP1.0)**：HTTP1.0时的遗留字段，当值为"no-cache"时强制验证缓存，Pragma禁用缓存，如果又给Expires定义一个还未到期的时间，那么Pragma字段的优先级会更高。服务端响应添加'Pragma': 'no-cache'，浏览器表现行为和刷新(F5)类似。

**Cache-Control(HTTP1.1)**：有很多属性，不同的属性代表的意义也不同：

- private：客户端可以缓存 
- public：客户端和代理服务器都可以缓存 
- max-age=t：缓存内容将在t秒后失效 
- no-cache：需要使用协商缓存来验证缓存数据 
- no-store：所有内容都不会缓存 

请注意no-cache指令很多人误以为是不缓存，这是不准确的，no-cache的意思是可以缓存，但每次用应该去想服务器验证缓存是否可用。no-store才是不缓存内容。当在首部字段Cache-Control 有指定 max-age 指令时，比起首部字段 Expires，会优先处理 max-age 指令。命中强缓存的表现形式：Firefox浏览器表现为一个灰色的200状态码。Chrome浏览器状态码表现为200 (from disk cache)或是200 OK (from memory cache)。

**协商缓存** 

**协商缓存需要进行对比判断是否可以使用缓存。**浏览器第一次请求数据时，服务器会将缓存标识与数据一起响应给客户端，客户端将它们备份至缓存中。再次请求时，客户端会将缓存中的标识发送给服务器，服务器根据此标识判断。**若未失效，返回304状态码，**浏览器拿到此状态码就可以直接使用缓存数据了。

- etag —— if-none-match
- last-modified —— if-modified-since

**Last-Modified**：服务器在响应请求时，会告诉浏览器资源的最后修改时间。

**if-Modified-Since**：浏览器再次请求服务器的时候，请求头会包含此字段，后面跟着在缓存中获得的最后修改时间。服务端收到此请求头发现有if-Modified-Since，则与被请求资源的最后修改时间进行对比，如果一致则返回304和响应报文头，浏览器只需要从缓存中获取信息即可。

- 如果真的被修改：那么开始传输响应一个整体，服务器返回：200 OK 
- 如果没有被修改：那么只需传输响应header，服务器返回：304 Not Modified 

**if-Unmodified-Since**: 从某个时间点算起, 是否文件没有被修改，使用的是相对时间，不需要关心客户端和服务端的时间偏差。

- 如果没有被修改：则开始`继续'传送文件，服务器返回: 200 OK 
- 如果文件被修改：则不传输，服务器返回: 412 Precondition failed (预处理错误) 

这两个的区别是一个是修改了才下载一个是没修改才下载。如果在服务器上，一个资源被修改了，但其实际内容根本没发生改变，会因为Last-Modified时间匹配不上而返回了整个实体给客户端（即使客户端缓存里有个一模一样的资源）。为了解决这个问题，HTTP1.1推出了Etag。

**Etag**：服务器响应请求时，通过此字段告诉浏览器当前资源在服务器生成的唯一标识（生成规则由服务器决定）

**If-Match**：条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改

**If-None-Match**： 再次请求服务器时，浏览器的请求报文头部会包含此字段，后面的值为在缓存中获取的标识。服务器接收到次报文后发现If-None-Match则与被请求资源的唯一标识进行对比。

- 不同，说明资源被改动过，则响应整个资源内容，返回状态码200。 
- 相同，说明资源无心修改，则响应header，浏览器直接从缓存中获取数据信息。返回状态码304. 

但是实际应用中由于Etag的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用Etag了。

- 浏览器地址栏中写入URL，回车浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿（最快） 
- F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since 
- Ctrl+F5告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作 

## 5、DNS解析

DNS解析的时候可以使用DNS缓存去减少重复操作，DNS缓存有浏览器DNS缓存、系统DNS缓存、路由DNS缓存、服务商DNS缓存。

DNS有两种查询的方式，分为递归查询和迭代查询。递归查询是访问根域名服务器，根域名服务器层层下发，找到目标域名的IP地址后返回。迭代查询是访问根域名服务器后，根域名服务器返回一个其他DNS服务器的地址，然后再向其他DNS服务器去查询。

## 6、Cookie 和Session、LocalStorage

**生命周期：** 

cookie：可设置失效时间，没有设置的话，默认是关闭浏览器后失效

localStorage：除非被手动清除，否则将会永久保存。

sessionStorage： 仅在当前网页会话下有效，关闭页面或浏览器后就会被清除。

**存放数据大小：** 

cookie：4KB左右

localStorage和sessionStorage：可以保存5MB的信息。

**http请求：** 

cookie：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题

localStorage和sessionStorage：仅在客户端（即浏览器）中保存，不参与和服务器的通信

**易用性：** 

cookie：需要程序员自己封装，源生的Cookie接口不友好。

localStorage和sessionStorage：源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。

**应用场景：** 

从安全性来说，因为每次http请求都会携带cookie信息，这样无形中浪费了带宽，所以cookie应该尽可能少的使用，另外cookie还需要指定作用域，不可以跨域调用，限制比较多。但是用来识别用户登录来说，cookie还是比stprage更好用的。其他情况下，可以使用storage，就用storage。

storage在存储数据的大小上面秒杀了cookie，现在基本上很少使用cookie了，因为更大总是更好的，哈哈哈你们懂得。

localStorage和sessionStorage唯一的差别一个是永久保存在浏览器里面，一个是关闭网页就清除了信息。localStorage可以用来夸页面传递参数，sessionStorage用来保存一些临时的数据，防止用户刷新页面之后丢失了一些参数。

**浏览器支持情况：** 

localStorage和sessionStorage是html5才应用的新特性，可能有些浏览器并不支持，这里要注意。

## 7、WebSocket

WebSocket 是除最初建立连接时需要借助于现有的HTTP协议，其他时候直接基于TCP完成通信。它可以让我们在客户端和服务器之间以数据流的形式实现各种应用数据交换（包括JSON 及自定义的二进制消息格式），而且两端都可以随时向另一端发送数据。

- 连接协商和同源策略；
- 与既有 HTTP 基础设施的互操作；
- 基于消息的通信和高效消息分帧；
- 子协议协商及可扩展能力。

## 8、Keep-alive

Connection:Keep-alive

HTTP协议采用“请求-应答”模式，不开启KeepAlive模式时，每个req/res客户端和服务端都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当开启Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。

## 9、HTTP与HTTPS的区别

1. HTTPS协议需要到CA（证书颁发机构）申请证书，一般免费证书很少，需要交费。
2. HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
3. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

## **10、HTTP2.0**

相对于HTTP1.0，HTTP1.1的优化：

- 缓存处理：多了Entity tag，If-Unmodified-Since, If-Match, If-None-Match等缓存信息（HTTTP1.0 If-Modified-Since,Expires） 
- 带宽优化及网络连接的使用 
- 错误通知的管理 
- Host头处理 
- 长连接： HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。 

相对于HTTP1.1，HTTP2的优化：

- HTTP2支持二进制传送（实现方便且健壮），HTTP1.x是字符串传送 
- HTTP2支持多路复用 
- HTTP2采用HPACK压缩算法压缩头部，减小了传输的体积 
- HTTP2支持服务端推送 

## **11、DNS缓存**

在浏览器中输入URL的时候，DNS会根据域名找到对应的IP地址。在DNS查找目标域名对应的IP地址的时候，首先会去访问浏览器缓存，看最近访问的网址中有没有目标域名，如果没有则会访问系统DNS缓存中的是否存在，依旧不存在则会去路由缓存中查找，但是还是不存在的话就会去ISP服务商的缓存中查找是否有目标域名的IP地址。如果缓存中都不存在则会访问根域名服务器去查找目标域名的IP地址，根域名服务器会层层下发直到找到对应域名的IP地址为止。

## **12、浏览器是如何渲染页面的**

浏览器从网络或硬盘中获得HTML字节数据后会经过一个流程将字节解析为DOM树：

- 编码： **先将HTML的原始字节数据转换为文件指定编码的字符。** 
- 令牌化： 然后**浏览器会根据HTML规范来将字符串转换成各种令牌**
- 生成对象： **接下来每个令牌都会被转换成定义其属性和规则的对象（这个对象就是节点对象）。** 
- 构建完毕： **DOM树构建完成，整个对象集合就像是一棵树形结构**。

整个DOM树的构建过程其实就是： **字节 -> 字符 -> 令牌 -> 节点对象 -> 对象模型。**

当上述HTML代码遇见<link>标签时，浏览器会发送请求获得该标签中标记的CSS文件（使用内联CSS可以省略请求的步骤提高速度，但没有必要为了这点速度而丢失了模块化与可维护性）。

在构建了DOM树和CSSOM树之后，浏览器只是拥有了两个互相独立的对象集合，DOM树描述了文档的结构与内容，CSSOM树则描述了对文档应用的样式规则，**想要渲染出页面，就需要将DOM树与CSSOM**树结合在一起，这就是渲染树。

- 浏览器会先从DOM树的根节点开始遍历每个可见节点（不可见的节点自然就没必要渲染到页面了，不可见的节点还包括被CSS设置了display: none属性的节点，值得注意的是visibility: hidden属性并不算是不可见属性，它的语义是隐藏元素，但元素仍然占据着布局空间，所以它会被渲染成一个空框）。
- 对每个可见节点，找到其适配的CSS样式规则并应用。
- 渲染树构建完成，每个节点都是可见节点并且都含有其内容和对应规则的样式。

渲染树构建完毕后，浏览器得到了每个可见节点的内容与其样式，下一步工作则**需要计算每个节点在窗口内的确切位置与大小，也就是布局阶段。** 

当Layout布局事件完成后，浏览器会立即发出Paint Setup与Paint事件，开始将渲染树绘制成像素，绘制所需的时间跟CSS样式的复杂度成正比，绘制完成后，用户就可以看到页面的最终呈现效果了。

## **13、GET和POST的区别**

- Get 请求能缓存，Post 不能。
- Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史记录，Post 不会，但是在抓包的情况下都是一样的。
- Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术。
- URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
- Post 支持更多的编码类型且不对数据类型限制。

## **14、URL输入浏览器的整个过程**

​    （1）、DNS缓存

​    （2）、TCP的三次握手

​    （3）、浏览器页面的渲染

​    （4）、TCP的四次握手

## **15、回流和重绘**

**何时触发回流和重绘** 

何时发生回流：

- 添加或删除可见的DOM元素 
- 元素的位置发生变化 
- 元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等） 
- 内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。 
- 页面一开始渲染的时候（这肯定避免不了） 
- 浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的） 

何时发生重绘（回流一定会触发重绘）：

当页面中元素样式的改变并不影响它在文档流中的位置时（例如：color、background-color、visibility等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。

有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。现代浏览器会对频繁的回流或重绘操作进行优化，浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。你访问以下属性或方法时，浏览器会立刻清空队列：

- clientWidth、clientHeight、clientTop、clientLeft 
- offsetWidth、offsetHeight、offsetTop、offsetLeft 
- scrollWidth、scrollHeight、scrollTop、scrollLeft 
- width、height 
- getComputedStyle() 
- getBoundingClientRect() 

以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，**最好避免使用上面列出的属性，他们都会刷新渲染队列。**如果要使用它们，最好将值缓存起来。

**如何避免触发回流和重绘** 

CSS：

- 避免使用table布局。 
- 尽可能在DOM树的最末端改变class。 
- 避免设置多层内联样式。 
- 将动画效果应用到position属性为absolute或fixed的元素上 
- 避免使用CSS表达式（例如：calc()） 
- CSS3硬件加速（GPU加速） 

JavaScript：

- 避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性 
- 避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中 
- 也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘 
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来 
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流 

## **16、HTTPS的握手**

1、客户端发送“ClientHello”消息，消息包含 SSL 的版本、客户端支持的加密套件和数据压缩算法及随机数1。

2、服务器响应“ServerHello”消息，消息包含选定的加密套件、选定的数据压缩方法、会话标识，数字证书及另一个随机数2。

3、客户端（ Web 浏览器）验证服务器的SSL数字证书的有效性，不通过则提示警告。

4、客户端发送“客户端密钥交换”消息。此消息包含 pre-master secret（用于生成对称加密密钥生的随机数3）。

5、客户端使用一系列加密运算将 [随机数1 随机数2 随机数3] 转化为 master secret，其中将派生出所有用于加密和消息认证的密钥。

6、服务器使用一系列加密运算将 [随机数1 随机数2 随机数3] 转化为 master secret，其中将派生出所有用于加密和消息认证的密钥。

7、客户端发出“更改密码规范”通知服务器端之后使用协商好的对称加密算法及密钥通信。

8、服务器发出“更改密码规范”通知客户端之后使用协商好的对称加密算法及密钥通信。

9、SSL握手结束，使用对称加密算法进行加密通信。

## 17、介绍下如何实现 token 加密

1. 需要一个secret（随机数）
2. 后端利用secret和加密算法(如：HMAC-SHA256)对payload(如账号密码)生成一个字符串(token)，返回前端
3. 前端每次request在header中带上token
4. 后端用同样的算法解密



## 18、介绍下 HTTPS 中间人攻击

中间人攻击过程如下：

1. 服务器向客户端发送公钥。
2. 攻击者截获公钥，保留在自己手上。
3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端。
4. 客户端收到伪造的公钥后，生成加密hash值发给服务器。
5. 攻击者获得加密hash值，用自己的私钥解密获得真秘钥。
6. 同时生成假的加密hash值，发给服务器。
7. 服务器用私钥解密获得假秘钥。
8. 服务器用加秘钥加密传输信息

防范方法：

服务端在发送浏览器的公钥中加入CA证书，浏览器可以验证CA证书的有效性

## 19、memory cache与disk cache区别

如果进程结束，内存则被清空就无法读取了，而磁盘的话是可以读取的。

serviceWork可以拦截（缓存）静态资源。

## 20、将url转换为对象

```
 function query(string) {
        // console.log(string) //  http://www.baidu.com?a=1&b=2&c=3
        let arr=string.split("?")  //截取字符，变为伪数组
        // console.log(arr) // ["http://www.baidu.com", "a=1&b=2&c=3"]
        let arr1=arr[1].split("&"); //截取字符，变为伪数组
        // console.log(arr1) // ["a=1", "b=2", "c=3"]
        let obj={}
        for (let i=0;i<arr1.length;i++){ //便利数组
            // console.log(i) //0 1 2
            let arr2=arr1[i].split("=") //截取arr1下面的每个=
            // console.log(arr2)  ["a", "1"] ["b", "2"] ["c", "3"]
            obj[arr2[0]]=arr2[1] //让obj[arr2数组下的每个下标为0的]=arr2的数组下的每个下标为1的
			}
			console.log(obj) //{a: "1", b: "2", c: "3"}
			console.log( typeof obj) //object
			return obj
}
```

## 21、http请求中的cookie可以怎么设置

![image-20190911094352928](/Users/caiyifan/Library/Application Support/typora-user-images/image-20190911094352928.png)

## 22、CDN原理性

给源站域名添加CNMAE，别名为加速节点的域名。当用户向源站发起请求时，dns服务器解析源站域名时会发现有CNMAE记录，这时dns服务器会向CNAME域名发起请求，请求会被调度至加速节点的域名。

