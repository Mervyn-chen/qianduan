# 自我介绍：

（1～1.5min）

# 手写题：

链表的倒数第n个节点

做一道题（10分钟）：大数据量高并发怎么从数据库设计和软件应用程序上来改善，不允许硬件设备改进。

# java:

线程和进程的区别

创建一个线程的语句

linklist和arraylist的区别

arraylist和hashset的区别

java线程

arraylist linkedlist

java的多态是怎么实现的

线程安全

软件开发过程

# 算法：

## 快排

利用分治法可将快速排序的分为三步：

1.在数据集之中，选择一个元素作为”基准”（pivot）。

2.所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。这个操作称为[分区 (partition) 操作](http://en.wikipedia.org/wiki/Quicksort)，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。

3.对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。

```javascript
function jsQuickSort(array) {
    if (array.length <= 1) {
        return array;
    }
    const pivotIndex = Math.floor(array.length / 2);
    const pivot = array.splice(pivotIndex, 1)[0];  //从数组中取出我们的"基准"元素
    const left = [], right = [];
    array.forEach(item => {
        if (item < pivot) {  //left 存放比 pivot 小的元素
            left.push(item); 
        } else {  //right 存放大于或等于 pivot 的元素
            right.push(item);
        }
    });
    //至此，我们将数组分成了left和right两个部分
    return jsQuickSort(left).concat(pivot, jsQuickSort(right));  //分而治之
}
const arr = [98, 42, 25, 54, 15, 3, 25, 72, 41, 10, 121];
console.log(jsQuickSort(arr));  //输出：[ 3, 10, 15, 25, 25, 41, 42, 54, 72, 98, 121 ]
```

## 二分查找

```javascript
function search(arr,low,height,key){
    height--;
    if(low>height){
        return -1;
    }
    var mid=Math.floor((low+height)/2);
    if(arr[mid]==key){
        return mid;
    }else if(arr[mid]<key){
        low=mid+1
        return search(arr,low,height,key);
    }else{
        mid=height-1;
        return search(arr,low,height,key);
    }
}
```

## 斐波那契

F(0)=1，F(1)=1, F(n)=F(n-1)+F(n-2)（n>2，n∈N*）

```javascript
function Fibonacci (n) {
  if ( n <= 1 ) {return 1};
  return Fibonacci(n - 1) + Fibonacci(n - 2);
}
```

## 青蛙跳台阶

一只青蛙一次可以跳上一阶台阶，也可以跳上二阶台阶，请这只可怜的青蛙跳上N阶台阶有几种方法？

```javascript
 function jumpFloor2(n) {
        var target = 0, number1 = 1, number2 = 2;
 
        if(n<=0)return 0;
        if(n == 1) return 1;
        if(n==2) return 2;
        for(var i=3;i<=n;++i) {
            target = number1 + number2;
            number1 = number2;
            number2 = target;
        }
        return target;
    }
```

# 数据结构：

## 递归和迭代的区别

**递归:**程序调用自身的编程技巧称为递归,是函数自己调用自己

**迭代:**利用变量的原值推算出变量的一个新值.如果递归是自己调用自己的话,迭代就是A不停的调用B.

1） 递归中一定有迭代,但是迭代中不一定有递归,大部分可以相互转换。

2） 能用迭代的不用递归,递归调用函数,浪费空间,并且递归太深容易造成堆栈的溢出

## B+树

B+ 树是一种树数据结构，是一个n叉树，每个节点通常有多个孩子，一颗B+树包含根节点、内部节点和叶子节点。B+ 树通常用于数据库和操作系统的文件系统中。 B+ 树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度。 B+ 树元素自底向上插入。

### B+树与B树的区别

- 有k个子结点的结点必然有k个关键码；
- 非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
- 树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。

# 数据库： 

## 事务管理（ACID）

原子性（Atomicity）
原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
一致性（Consistency）
事务前后数据的完整性必须保持一致。
隔离性（Isolation）
事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
持久性（Durability）
持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

## 数据库四范式



## 索引

B+树索引是B+树在数据库中的一种实现，是最常见也是数据库中使用最为频繁的一种索引。B+树中的B代表平衡。

优点：可以大大提高查询速度

缺点：

◆虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。

◆建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。

## join

## 脏读 幻读 不可重复读

脏读：

脏读发生在一个事务A读取了被另一个事务B修改，但是还未提交的数据。假如B回退，则事务A读取的是无效的数据。这跟不可重复读类似，但是第二个事务不需要执行提交。 

不可重复读：

在基于锁的并行控制方法中，如果在执行select时不添加读锁，就会发生不可重复读问题。在多版本并行控制机制中，当一个遇到提交冲突的事务需要回退但却被释放时，会发生不可重复读问题。

幻读： 

幻读发生在当两个完全相同的查询执行时，第二次查询所返回的结果集跟第一个查询不相同。

发生的情况：没有范围锁。

# 测试：

## 黑盒、白盒测试方法 

**白盒测试**：是一种测试用例设计方法，在这里盒子指的是被测试的软件，白盒，顾名思义即盒子是可视的，你可以清楚盒子内部的东西以及里面是如何运作的，因此白盒测试需要你对系统内部的结构和工作原理有一个清楚的了解，并且基于这个知识来设计你的用例。

白盒测试技术一般可被分为静态分析和动态分析两类技术。

静态分析主要有：控制流分析技术、数据流分析技术、信息流分析技术。

动态分析主要有：逻辑覆盖率测试(分支测试、路径测试等)，程序插装等。

白盒测试优点：迫使测试人员去仔细的思考软件的实现；可以检测代码中的每条分支和路径；揭示隐藏在代码中的错误；对代码的测试比较彻底；最优化。

白盒测试缺点：昂贵；无法检测代码中遗漏的路径和数据敏感性错误；不验证规格的正确性。

**黑盒测试**又叫功能测试，这是因为在黑盒测试中主要关注被测软件的功能实现，而不是内部逻辑。在黑盒测试中，被测对象的内部结构，运作情况对测试人员是不可见的，测试人员对被测产品的验证主要是根据其规格，验证其与规格的一致性。

在绝大多数没有用户参与的黑盒测试中，最常见的测试有：功能性测试、容量测试、安全性测试、负载测试、恢复性测试、标杆测试、稳定性测试、可靠性测试等。

## 常用的软件测试工具



# 网络：

## 对称加密和非对称加密

`对称加密`:A与 B 之间之间的通讯数据都用同一套的密钥来进行加密解密。

- 优点
  简单快捷，密钥较短，且破译困难。
- 缺点
  如果用户一旦多的话，管理密钥也是一种困难。不方便直接沟通的两个用户之间怎么确定密钥也需要考虑，这其中就会有密钥泄露的风险，以及存在更换密钥的需求。
- 对称加密通常有 DES,IDEA,3DES 加密算法。

`非对称加密`：用公钥和私钥来加解密的算法。打个比方，A 的公钥加密过的东西只能通过 A 的私钥来解密；同理，A 的私钥加密过的东西只能通过 A 的公钥来解密。顾名思义，公钥是公开的，别人可以获取的到；私钥是私有的，只能自己拥有。

- 缺点
  加解密比对称加密耗时.
- 优点
  比对称加密安全.

## 数字签名

数字签名用来，保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。
数字签名是 A将原始明文通过 hash 算法得到摘要，这个摘要是不可逆的；将明文加密，连同摘要一起发送给B；B接收到后解密，得到这个摘要 `a` 和加密的明文，再将加密明文解密得到原始明文，然后通过同一 hash 算法得到新的摘要 `b`，比较 `a` 与 `b` 就可得知在传输过程中是否被更改过。
因此数字签名能够验证信息的完整性。如果中途数据被纂改或者丢失。那么对方就可以根据数字签名来辨别是否是来自对方的第一手信息数据。



http与https的区别；

写一个MAX的宏定义；

链表和数组的区别；

字符串转整形的函数；

LINUX常用命令5个；

cd ls mv cp tar chomd vim ……





作者：跪求西安offer
https://www.nowcoder.com/discuss/248887?type=post&order=time&pos=&page=1来源：牛客网

1.一组10个人，每个人依次做自我介绍，介绍中主要突出奖学金啊，各种竞赛的奖啊，论文等，面试官会比较喜欢。自我介绍中，面试官会对比较感兴趣的人稍作提问，如实习情况 

2.屏幕上出现一道题，8分钟时间，在纸上写出自我的想法，思路等，然后挨个给面试官讲解自己的想法，这里就算不会也没有关系，自己知道多少说多少，尽可能的把自己知道的都说出来就好 

3.面试官随机对考生进行提问，会直接问哪个考试什么问题，有的是关于简历上写的，有的是基础的，下面试我们组我记录的一些问题 

所有问题： 

1.http和https区别 

2linux常见的命令(压缩和解压缩，创建文件) 

3.delete和t区别 

4.tcp和udp区别 

5.线程间通信方式 

6.什么是线程间的通信 

7.线程和进程区别 

8.触发器 

9.索引创建的规则 

10.cookie和session区别 

11.线程有哪几种状态 

12.说出5种排序算法 

大概一组面试完1个小时左右吧 



下面给出我了解到的其他组的问题 

1、什么是缓存？ 

2、写出三种缓存策略 

3、缓存会导致什么问题？ 

4.幻读 

5.泊松分布中lambda参数是什么含义？ 

6.二叉树层次遍历用到的数据结构是什么？ 

7.说出5种排序算法 

8.二叉树有几种遍历算法，时间复杂度是多少？ 

9.在网页地址栏输入网址，按回车之后都完成了哪些过程 

10.进程和线程的区别 

11.tcp和udp的区别 

12.数据库连接是tcp的还是udp的 

13.数据库char和varchar的区别 

14.说一下数据库的隔离级别。 

15.二叉树有几种遍历算法，时间复杂度是多少？ 

16.不稳定性是啥？快排是稳定的吗，为什么不稳定 

17.索引和插件的区别 

18.进程间通信 

19.如何创建线程 

20.sql攻击 

21.spring boot的优势 

22.springboot和springcloud 

23.DML DDL

24.删除数据的方式 

25.集合有哪几种 

26.异常机制 

27.回收机制 

28.string Arraylist