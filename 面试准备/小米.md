大致流程：

1.自我介绍（1m）

2.详细的实习项目介绍(5m)

3.巴拉巴拉问题(4~5个问题，4min/个)

4.为什么选前端？怎么学习前端？未来的规划？有什么想问的？(5m)



# HTTP

####  说一说常见的http状态码？304,405？

100     Continue 服务器收到请求，需要继续执行操作
200     OK 成功，操作被成功接收并处理
301 redirect: 301 代表永久性转移(Permanently Moved)

302 redirect: 302 代表暂时性转移(Temporarily Moved )

304 Not Modified请求未修改

404Not Found 

500Internal Server Error 服务器错误

#### http缓存

浏览器第一次向一个web服务器发起`http`请求后，服务器会返回请求的资源，并且在响应头中添加一些有关缓存的字段如：`Cache-Control`、`Expires`、`Last-Modified`、`ETag`、`Date`等等。之后浏览器再向该服务器请求该资源就可以视情况使用**强缓存**和**协商缓存**。

- 强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互。
- 协商缓存：浏览器发送请求到服务器，服务器判定是否可使用本地缓存。
- 联系与区别：两种缓存方式最终使用的都是本地缓存；前者无需与服务器交互，后者需要。

#### 如何解决跨域问题？

通过img标签的src属性
通过**JSONP**动态插入script标签，执行回调函数
通过跨域资源共享（**CORS**）发送AJAX请求，普通跨域请求只需在服务端设置**Access-Control-Allow-Origin**即可。而带有cookie的跨域请求，还需在服务端设置Access-Control-Allow-Credentials，且前端设置xhr对象的withCredentials属性为true。
通过**配置代理服务器**，如**nginx**反向代理proxy_pass字段，nodejs中间件，webpackserver的proxy属性等。

通过**HTML5API PostMessage**实现多页面，多窗口以及iframe之间的的通信

#### 如何理解http是无状态的

HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和你之前打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。

#### OPTION请求

HTTP 的 OPTIONS 方法 用于获取目的资源所支持的通信选项。客户端可以对特定的 URL 使用 OPTIONS 方法，也可以对整站（通过将 URL 设置为“*”）使用该方法。

#### 地址栏输入URL会发生什么？

客户端获取URL - > DNS解析 - > TCP连接 - >发送HTTP请求 - >服务器处理请求 - >返回报文 - >浏览器解析渲染页面 - > TCP断开连接

客户端：

（应用层开始）获取URL，通过负责域名解析的DNS服务获取网址的IP地址，根据HTT协议生成HTTP请求报文（应用层结束）

（传输层开始）根据TCP协议连接从客户端到服务端（通过三次握手）客户端给服务端发送一个带SYN（同步）标志的数据包给客户端，然后客户端接收到信息再给客户端回传一个带有SYN / ACK（确认）标志的数据包以示传达确认信息，客户求最后端的再传送一个带ACK标志的数据包，代表“握手”结束，连接成功.TCP协议在把请求报文按序号分割成多个报文段（传输层结束）

（网络层开始）根据IP协议（传输数据），ARP协议（获取MAC地址），OSPF协议（选择最优路径），搜索服务器地址，一边中转一边传输数据（网络层结束）

（数据链路层开始）到达后通过数据链路层，物理层负责0,1比特流与物理设备电压高低，光的闪灭之间的互换。数据链路层负责将0,1序列划分为数据帧从一个节点传输到临近的另一个节点，这些节点是通过MAC来唯一标识的（MAC，物理地址，一个中主机会有一个MAC地址）。 （数据链路层结束）

服务端

通过数据链路层 - >通过网络层 - >再通过传输层（根据TCP协议接收请求报文并重组报文段） - >再通过应用层（通过HTTP协议对请求的内容进行处理） - >再通过应用层 - >传输层 - >网络层 - >数据链路层 - >到达客户端

客户端

通过数据链路层 - >网络层 - >传输层（根据TCP协议接收响应报文并重组） - >应用层（HTTP协议对响应进行处理） - >浏览器渲染页面 - >断开连接协议四次挥手） 

#### cache-control 浏览器缓存

# CSS

#### 行内元素怎么垂直水平居中

div{text-align:center; height:30px; line-height:30px} 

#### 盒子垂直、水平居中

- 水平居中：给div设置一个宽度，然后添加margin:0 auto属性

  ```javascript
  div{
   	width:200px;
   	margin:0 auto;
    }
  ```

- 让绝对定位的div居中

  ```javascript
  div {
   	position: absolute;
   	width: 300px;
   	height: 300px;
   	margin: auto;
   	top: 0;
   	left: 0;
   	bottom: 0;
   	right: 0;
   	background-color: pink;	/* 方便看效果 */
   }
  ```

1.外边距为自身宽高的一半

2.未知宽高，利用transform:translate(-50%,-50%)

3.flex

```javascript
.container {
 	display: flex;
 	align-items: center; 		/* 垂直居中 */
 	justify-content: center;	/* 水平居中 */

 }
 .container div {
 	width: 100px;
 	height: 100px;
 	background-color: pink;		/* 方便看效果 */
 }
```

#### position属性说一下，具体效果？

absolute元素不设置left和top时会在哪个位置(父元素顶部,但是是包括static的父元素)

```
absolute
  	生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。
    fixed （老IE不支持）
  	生成绝对定位的元素，相对于浏览器窗口进行定位。
    relative
  	生成相对定位的元素，相对于其正常位置进行定位。
    static
  	默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
    inherit
  	规定从父元素继承 position 属性的值。
```

#### *display，float，position这三者的优先级

#### 浮动float(left, right)


使元素脱离文档流，按照指定的方向（左或右发生移动），直到它的外边缘碰到包含框或另一个浮动框的边框为止。文档流是是文档中可显示对象在排列时所占用的位置/空间，而脱离文档流就是在页面中不占位置了。

浮动会带来什么问题：高度塌陷，脱离文档流

清除浮动：clear:both，伪元素clearfix:after{content:””; display:block; clear:both;}

#### px rem em

em相对于父元素，rem相对于根元素(不可修改)，默认1rem=16px

#### 元素宽度自适应,高度保持比例放大缩小怎么实现



#### 触发BFC的条件

 1.float的值不为none

2.overflow的值不为visible

3.display的值为table-cell、tabble-caption和inline-block之一

4.position的值不为static或则releative中的任何一个

 

8.写css动画,实现元素左右循环往复平移

css3新属性,H5新增标签及属性。

#### box-sizing

content-box

Border-box

渲染过程？

回流重绘相关

# JS

#### js基础类型,与引用类型的区别



null == undefined(true) ""==null(true) 1+null=?(1) 1+undefiend=?(NaN)

#### valueof()和tostring()

toString()和valueOf()都是对象的方法。toString()方法返回反映这个对象的字符串。valueOf()方法如果存在任意原始值，它就默认将对象转换为表示它的原始值；对象是复合值，而大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值。

（1）undefined和null没有toString()和valueOf()方法

……https://www.jianshu.com/p/24547d4e565f

#### 写一个大数相加

https://www.jianshu.com/p/8f73cc7e1109

说一下JS的Event Loop

#### js事件传播流程

js事件传播流程主要分三个阶段:事件捕获阶段、处于目标阶段、事件冒泡阶段。

在我们平常用的addEventListener方法中，一般只会用到两个参数，一个是需要绑定的事件，另一个是触发事件后要执行的函数，然而，addEventListener还可以传入第三个参数，第三个参数默认值是false，表示在事件冒泡阶段调用事件处理函数;如果参数为true，则表示在事件捕获阶段调用处理函数。

**(1).** 捕获阶段：事件从根节点流向目标节点，途中流经各个DOM节点，在各个节点上触发捕获事件，直到达到目标节点。

**(2).** 目标（target）阶段：在此阶段中，事件传导到目标节点。浏览器在查找到已经指定给目标事件的监听器后，就会运行该监听器。

**(3).** 事件冒泡: 当为多个嵌套的元素设置了相同的事件处理程序，它们将触发事件冒泡机制。在事件冒泡中，最内部的元素将首先触发其事件，然后是栈内的下一个元素触发该事件，以此类推，直到到达最外面的元素。如果把事件处理程序指定给所有的元素，那么这些事件将依次触发。

**如何阻止冒泡**   

可以调用事件对象的stopPropagation()方法以阻止事件的继续传播。如果在同一对象上定义了其他处理程序，剩下的处理程序将依旧被调用，但调用stopPropagation()之后任何其他对象上的事件处理程序将不会被调用。

说一下闭包

解释闭包（顺便引申到了静态作用域，动态作用域）

\16. 闭包带来的问题是什么

\17. 什么情况下用闭包

\18. 说一下原型链

\19. 原型链最顶端是什么 Function.prototype.__proto__

\20. Object.__proto__是什么？

\3. 了解过哪些ES6

#### let和var在循环中的区别

\4. 箭头函数内部this指向啥

\5. 怎么改变箭头函数this

\6. 怎么改变普通函数this

ajax用来干嘛？

#### 绑定事件方法

1. 在DOM元素中直接绑定；

2. 在JavaScript代码中绑定；

   ```javascript
   elementObject.onXXX=function(){
   
       // 事件处理代码
   
   }
   ```

   

3. 绑定事件监听函数。addEventListener() 或 attachEvent()

#### call、apply、bind区别

\8. 说一下怎么实现bind 说一下思路

查找数组中的最大值

找出数组中出现次数大于n的元素

#### 字符串逆序

reverse()

charAt() 方法可返回指定位置的字符。

用压栈的方法

```javascript
function reverse( str ){
   var arr = [];//生成一个栈
   for(var len = str.length,i=len;i>=0;i-- ){
   		arr.push(str[i]);
	}
   return arr.join('');
}
var str = "hello world";
var res = reverse(str);
console.log(res);
```

#### reduce

`reduce() 方法接收一个函数作为累加器`,reduce 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：初始值（上一次回调的返回值），当前元素值，当前索引，原数组 

语法：`arr.reduce(callback,[initialValue])`



**应用**

```javascript
const arr = [1, 2, 3, 4, 5]
const sum = arr.reduce((pre, item) => {
    return pre + item
}, 0)
console.log(sum) // 15
```

#### 如何模拟一个map

map及weakmap的区别，及weakmap的使用场景

如何判断标签是div(ps:话说好简单，查找，创建用的多，不太了解这个呀)

12.宏任务，微任务，（promise,setTimeOut执行顺序）

diff算法的原理，时间复杂度

常见设计模式有哪些？

https://www.cnblogs.com/lexiaoyao1992/p/9759389.html

https://www.jianshu.com/p/d8c1c426d028

# git

git fetch和pull区别 git reset --soft 和 --hard区别



# Vue

#### vue双向数据绑定原理

每当数据有变更时，我们会再次进行渲染，从而更新视图，使得视图与数据保持一致。而另一方面，页面也会通过用户的交互，产生状态、数据的变化，这个时候，我们则编写代码，将视图对数据的更新同步到数据，以致于同步到后台服务器。数据与视图的绑定与同步，最终体现在对数据的读写处理过程中。Object.defineProperty() 定义的数据 set、get 函数中。

```javascript
function defineReactive(obj, key, value) {
    var dep = new Dep()
    Object.defineProperty(obj, key, {
        enumerable: true,
        configurable: true,
        get: function reactiveGetter() {
            if (Dep.target) {
                dep.depend()
            }
            return value
        },
        set: function reactiveSetter(newVal) {
            if (value === newVal) {
                return
            } else {
                value = newVal
                dep.notify()
            }
        }
    })
}
```



#### MVVM

在vue中：Model:指的是js中的数据，如对象，数组等等。View:指的是页面视图viewModel:指的是vue实例化对象。在MVVM中View和Model是不可以直接进行通信的，它们之间存在这ViewModel这个中介充当着观察者的角色。当用户操作View，ViewModel感知到变化，然后通知Model发生相应改变，反之亦然。ViewModel向上与视图层View进行双向数据绑定，向下与Model通过接口请求进行数据交互，起到承上启下的作用。

MVC是Model-View- Controller的简写。即模型-视图-控制器。M和V指的意思和MVVM中的M和V意思一样。C即Controller指的是页面业务逻辑。使用MVC的目的就是将M和V的代码分离。‘MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。

#### vue生命周期

一般事件处理写在哪个生命周期 mounted

vue   <keep-alive>实现缓存原理

http使用keep-alive后，如何将响应报文与请求报文一一对应(不能通过cookie来判断)

虚拟dom

#### vue数据更新监听

#### vue函数式组件

vue中设置key值的作用

3.原声js修改页面与vue修改页面的性能比较，还要分析原因，以及原声js优化到极致后与vue的性能比较

8.打包优化，被问到vue怎么做异步加载(我说的是用.webpack的chunk语法加上vue的import()函数，不知道蒙对了没有)



前端性能优化



一个开放性的问题：你是怎么理解编程语言的多样性的，为什么我们要设计这么多编程语言



0.自我介绍、项目介绍

1.px em rem区别

2.三栏布局

3.js事件队列

4.实现js异步编程的四种方式

*给了一段代码问输出：(大概是这= =)

```javascript
setTimeout(function() {
  console.log(11111);
}, 0);
new Promise(resolve => {
  console.log(22222);
  resolve(33333);
  console.log(44444);
}).then(function() {
  console.log(55555);
});
console.log(66666);
//脑子一抽一开始就说错了，原地哭泣！！！
//22222
//33333
//44444
//66666
//55555
//11111
```

补充：发现33333需要修改一下resolve(console.log(33333));才能输出

5.如何解决跨域

6.节流、防抖

7.插槽和预插槽（没咋用过，没回答上来）

……可能漏了点

8.手撕：







