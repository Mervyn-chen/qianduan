### 你做的页面在哪些流览器测试过？这些浏览器的内核分别是什么?

IE: trident内核

Firefox：gecko内核

Safari:webkit内核

Opera:以前是presto内核，Opera现已改用Google Chrome的Blink内核

Chrome:Blink(基于webkit，Google与Opera Software共同开发)

### 为什么利用多个域名来存储网站资源会更有效？

1.CDN缓存更方便;

2.突破浏览器并发限制;
3.节约cookie带宽;
4.节约主域名的连接数，优化页面响应速度;
5.防止不必要的安全问题。

### http协议中post和get方法的区别

1，



### 常见的跨域技术

通过img标签的src属性
通过JSONP动态插入script标签，执行回调函数
通过跨域资源共享（CORS）发送AJAX请求，普通跨域请求只需在服务端设置Access-Control-Allow-Origin即可。而带有cookie的跨域请求，还需在服务端设置Access-Control-Allow-Credentials，且前端设置xhr对象的withCredentials属性为true。
通过配置代理服务器，如nginx反向代理proxy_pass字段，nodejs中间件，webpackserver的proxy属性等。
通过websocket进行跨域

通过HTML5API PostMessage实现多页面，多窗口以及iframe之间的的通信

**document.domain + iframe 跨域**

此方案仅限主域相同，子域不同的跨域应用场景。

### Https的主要特点？

https = http + 完整性保护（报文摘要） + 认证 + 加密
HTTPS只是HTTP通信接口部分用SSL或TLS等协议代替而已。当通信时，HTTP先与SSL通信，再由SSL和TCP进行通信。
https使用混合加密机制，首先使用非对称加密换取对称加密密钥，再使用对称加密传输数据信息
https使用数字证书认证机构（CA）和其相关机构颁发的公开密钥证书，可以使客户端验证服务器公开密钥的真实性。

https在发送数据时，会附加MAC报文摘要，从而防止报文在传输过程中遭遇篡改

### xss和crsf是什么？各有什么防御手段？

xss为跨站脚本攻击，攻击者向web网页中恶意植入代码，用户访问该页面时，就会受到攻击。防御手段：对输入(和URL参数)进行过滤并对输出进行编码，例如单双引号、反斜线、大于和小于号。如果script、img、link以及background等标签或属性为动态内容，要确保这些url是安全的。在服务端对cookie设置http only，防止攻击者窃取cookie值。

crsf为跨站请求伪造，指攻击者通过设置好的陷阱，强制对已完成认证的用户进行非预期的个人信息或设定信息等某些状态更新。防御手段：验证HTTP Refer（缺点：老版的浏览器可可以篡改Refer），toke验证（在http请求中加入随机产生的toke，服务端进行合法性验证，缺点对每个请求都加入token比较麻烦，且token可能会被refer属性暴露），自定义HTTP属性头（通过XMLHttpRequest这个类，给http请求加上属性头，缺点为只限于ajax）

### 说一下TCP的3次握手连接和4次挥手断开连接，为什么一个是3次，一个是4次？

三次握手：客户端向服务端发送一个SYN报文，服务端收到报文确认后，发送一个SYN-ACK报文，客户端收到服务器的报文后，返回一个ACK报文，连接建立。

四次挥手：客户端向服务端发送一个FIN报文，服务端收到报文后，立即发送一个ACK报文，随即通知本地服务启动清理工作，当清理完成时，发送一个FIN报文给客户端，客户端收到后返回一个ACK报文，连接关闭。

### **长轮询和短轮询是什么？**

### DNS的解析过程是什么？

首先检查浏览器缓存中以及操作系统缓存中有没有对应的已解析过的结果（hosts文件），若没有则请求本地域名服务器（LDNS）来解析这个域名，若未成功解析，则跳转到根域名服务器，根域名服务器给予一个主域名服务器地址，然后本地域名服务器再去请求主域名服务器地址，接着主域名服务器会返回网站注册域名的服务器Name server的地址，本地服务器又去访问Name server，最终找到ip地址并返回给本地域名服务器，然后缓存该ip地址，解析结束。

### 说一下浏览器从发起请求到呈现页面的整个过程？

DNS解析ip地址 > TCP三次握手连接 > 发送HTTP请求 > 服务器处理，返回HTTP响应 > 浏览器解析响应 > 构建DOM树、CSSrule树，合并生成render树，计算布局并绘制

### 说一下meta标签有什么用？

元素可提供有关页面的元信息（meta-information），比如针对搜索引擎、更新频度、cookie的描述和关键词。元数据总是以名称/值对的形式表示，名称有两种类型：`name`和`http-equiv`。其中当名称为`http-equiv`，会将值关联到HTTP头部。

```
<meta http-equiv="Refresh" content="5;url=http://blog.yangchen123h.cn" />  5秒跳转
<meta name="viewport" content="width=device-width, initial-scale=1.0">  页面适配
<meta http-equiv="charset" content="iso-8859-1">   声明字符集
<meta http-equiv="expires" content="31 Dec 2008">   声明过期时间
```

### HTML文档有哪几种文档类型？为什么要进行类型声明？

严格型（strict）、过渡型（transitional）和框架型（Frameset）
严格型不包括框架集、一些废弃的元素标签，过渡型包含废弃的元素标签，但不允许框架集。而框架型等同于过渡型，且允许框架。
作用：只有进行正确的类型声明，浏览器才能正确的解析html文档。

### **HTTP2有什么特点**？

HTTP/2采用二进制格式而非文本格式。
在应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。在该二进制分帧层中，HTTP2.0将传输的消息划分为更小的消息和帧，并采用二进制编码。其中HTTP1.1的首部信息被封装到HEADER frame，而请求实体被封装到DATA frame中。
HTTP/2是完全多路复用的，而非有序并阻塞的——只需一个连接即可实现并行
使用报头压缩，HTTP/2降低了开销（采用了HPACK压缩算法）

HTTP/2让服务器可以将响应主动“推送”到客户端缓存中



### 谈谈你对对HTML语义化的理解？

1.什么是HTML语义化？
        基本都是围绕着几个主要的标签，像标题（H1~H6）、列表（li）、强调（strong em）等等）
        根据内容的结构化（内容语义化），选择合适的标签（代码语义化）
        便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。
       2.为什么要语义化？
        为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构；
        用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；
       有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重。
       方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方法来渲染页面；
       便于团队开发和维护，语义化更具可读性，是下一步页面的重要动向，遵循W3C标准的团队都要遵循这个标准，可以减少差异化。
      3.语义化标签

```
  <header>头部</header>
        <nav>导航</nav>
        <article>
         <section></section>
         <article>
         <footer>尾部</footer>
```

### 状态码

状态码 304 表示：如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。 307 表示临时重向！！！ )

100-199 用于指定客户端应相应的某些动作。 
200-299 用于表示请求成功。 
300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。 
400-499 用于指出客户端的错误。 （自己电脑这边的问题） 自己电脑这边的问题） 
500-599 用于支持服务器错误。 （对方的问题） 对方的问题）

400 （错误请求） 服务器不理解请求的语法。 
401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 
403 （禁止） 服务器拒绝请求。 
404 （未找到） 服务器找不到请求的网页。 

505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

### **cookie、localStorage、sessionStorage的区别是什么？**

共同点：都是保存在浏览器端、且同源的
区别：
1、cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递，而sessionStorage和localStorage不会自动把数据发送给服务器，仅在本地保存。cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下
2、存储大小限制也不同，cookie数据不能超过4K，同时因为每次http请求都会携带cookie、所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大
3、数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭之前有效；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie：只在设置的cookie过期时间之前有效，即使窗口关闭或浏览器关闭
4、作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localstorage在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的  (独立的存储空间)
5、web Storage支持事件通知机制，可以将数据更新的通知发送给监听者

6、web Storage的api接口使用更方便



cookie保存在客户端，比较不安全；session保存在服务器端，比较安全。

cookie目的可以跟踪会话，也可以保存用户喜好或者保存用户名密码，session用来跟踪会话。

建议用户名，密码保存在session，其它信息可保存在cookie。

### **分别列举几个HTTP请求头字段和响应头字段？**

###### 请求首部字段：

**Accept：**告知服务器，用户代理支持的媒体类型及相对优先级

**Accept-Charset：**告知服务器，用户代理支持的字符集及相对优先级，格式与Accept类似，常应用于服务器驱动协商

**Accept-Encoding：**告知服务器，用户代理支持的内容编码及相对优先级，格式与Accept类似，可指定多种编码

**Accept-Language：**告知服务器，用户代理支持的自然语言及相对优先级，格式与Accept类似

**Authorization**：告知服务器，用户代理的认证信息（证书值），通常在**401 Unauthorized** 响应后将其加入请求头部

**Expect**：告知服务器，期望出现的某种特定行为 
例如在POST大数据时，征询服务器是否能处理，若能，则返回100-continue状态码，否则返回417 Expectation Failed状态码

**From**：告知服务器，使用用户代理的用户电子邮箱地址

**Host**：告知服务器，请求资源所处的互联网主机及端口号 
在Http/1.1中，该字段必须被包含在首部字段中，可设置为空值。常用于区分运行在同一IP之上的多台虚拟主机

**Proxy-Authorization**：与Authorization字段类似，但用于客户端与代理服务器之间，告知代理认证信息

**Range**：用于范围请求，告知服务器请求资源的范围，若处理成功，则返回206 Partial Content响应，否则返回全部资源

**Referer**：告知服务器请求发出来源的URI，可用于查看请求是从哪个Web页面发出的

**User-Agent**：告知服务器，创建请求的浏览器和用户代理名称等信息 
如果请求经过代理，则可能会附加代理服务器的名称

###### 响应请求字段

**Accept-Ranges**：告知客户端，服务器是否能处理范围请求，若能，该字段值为bytes，否则为none

**Age**：告知客户端，源服务器在多久之前创建了该响应。若创建响应的服务器是缓存服务器，则age值代表该缓存从源服务器生成开始经历的时间（秒），当代理创建响应时，该字段必须被加入

**Location**：重定向的URI地址 
该字段会配合3XX Redirection响应，提供重定向的URI地址，几乎所有浏览器在接收到该字段时，都会尝试去访问

**Server**：告知客户端当前服务器上安装的HTTP服务器应用程序信息

**Proxy-Authenticate**：将代理服务器所要求的认证信息发送给客户端

**ETag**：资源标识符 
每个资源都对应着一个唯一的标识符，当资源更新时，标识符也随之更新

- 强ETag值：无论资源实体发生多么细微的变化，该值都会改变

- 弱ETag值：只有资源发生了根本的变化，产生差异时，才会改变值，这时，会在该字段值的前方附加W/

  

### **HTTP强缓存和协商缓存是什么？**

缓存的优点：

- 减少了不必要的数据传输，节省带宽
- 减少服务器的负担，提升网站性能
- 加快了客户端加载网页的速度
- 用户体验友好



### 前端页面有哪三层构成，分别是什么?作用是什么?

1.结构层 Html 

2.表示层 CSS 

3.行为层 js

### html语义化是什么？

当页面样式加载失败的时候能够让页面呈现出清晰的结构；
有利于seo优化，利于被搜索引擎收录（更便于搜索引擎的爬虫程序来识别）；
便于项目的开发及维护，使html代码更具有可读性，便于其他设备解析。

### **前端页面如何优化？**

**渲染优化**

禁止使用iframe（阻塞父文档onload事件）

禁止使用gif图片实现loading效果（降低CPU消耗，提升渲染性能）

使用CSS3代码代替JS动画（尽可能避免重绘重排以及回流）

对于一些小图标，可以使用base64位编码，以减少网络请求。（减少http请求，避免文件跨域，修改及时生效）

前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数

用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。

当需要设置的样式很多时设置className而不是直接操作style。

少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。

避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。

对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。 向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法"优化"的。



**1.内容方面**

1.减少 HTTP 请求 (Make Fewer HTTP Requests)

2.减少 DOM 元素数量 (Reduce the Number of DOM Elements)

3.使得 Ajax 可缓存 (Make Ajax Cacheable)

**2.css方面**

1.把 CSS 放到代码页上端

2.从页面中剥离 JavaScript 与 CSS 

3.精简 JavaScript 与 CSS

4.避免 CSS 表达式 

**3.针对JavaScript**

1. 脚本放到 HTML 代码页底部 

2. 从页面中剥离 JavaScript 与 CSS

3. 精简 JavaScript 与 CSS 

4. 移除重复脚本

**4.针对图片**

1.优化图片

2 不要在 HTML 中使用缩放图片

3 使用恰当的图片格式

4 使用 CSS 雪碧图 技巧对图片优化